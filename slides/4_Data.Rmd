---
title: "Data"
output:
  slidy_presentation:
    duration: 60
---

## Part 4 - Data

* Data types
* From vectors to matrices and lists

## Data types

* logical
* integer
* double
* character

## What is it?

```{r}
x <- 6
typeof(x)

x <- 6L
typeof(x)

x <- TRUE
typeof(x)

is.logical(x)

is.double(x)

class(x)

class(pi)
class(4L)
class(1:4)
```

## Dates and times

Dates in R can be tricky. Two basic classes: "Date" and "POSIXt". The former doesn't handle time intervals.

My recommendation is to stick with the "Date" class. Introducing times means introducing time zones and possibility for confusion or error.

```{r }
x <- as.Date('2010-01-01')
class(x)
typeof(x)

# Dates don't follow US conventions.
# Don't do this:
# x <- as.Date('06-30-2010')

# But this is just fine:
x <- as.Date('30-06-2010')

x <- Sys.Date()
class(x)
```

## More reading on dates

The `lubridate` package has some nice convenience functions for setting month and day and reasoning about time periods. It also enables you to deal with time zones, leap days and leap seconds. Probably more than you need.

* [Date class](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Dates.html)
* [lubridate](http://www.jstatsoft.org/v40/i03/paper)
* [Ripley and Hornik](http://www.r-project.org/doc/Rnews/Rnews_2001-2.pdf)

## Questions

* Create a logical, integer, double and character variable.
* Can you create a vector with both logical and character values?
* What happens when you try to add a logical to an integer? An integer to a double?

## Answers
```{r }
myLogical <- TRUE
myInteger <- 1:4
myDouble <- 3.14
myCharacter <- "Hello!"

y <- myLogical + myInteger
typeof(y)
y <- myInteger + myDouble
typeof(y)
```

## From vectors to matrices and lists

A matrix is a vector with higher dimensions.

A list has both higher dimensions, but also different data types.

## A matrix

Two ways to construct:

1. Use the `matrix` function.
2. Change the dimensions of a `vector`.

```{r }
myVector <- 1:100
myMatrix <- matrix(myVector, nrow=10, ncol=10)

myOtherMatrix <- myVector
dim(myOtherMatrix) <- c(10,10)

identical(myMatrix, myOtherMatrix)
```

## Matrix metadata

Possible to add metadata. This is typically a name for the columns or rows.

```{r }
colnames(myMatrix) <- letters[1:10]
View(myMatrix)
rownames(myMatrix) <- tail(letters, 10)
View(myMatrix)
```

## Data access for a matrix

Matrix access is similar to vector, but with additional dimensions. For two-dimensional matrices, the order is row first, then column. Single index will return values by indexing along only one dimension.

```{r }
myMatrix[2, ]
myMatrix[, 2]
myMatrix[2]
myMatrix[22]
```

## Matrix summary

```{r }
sum(myMatrix)
colSums(myMatrix)
rowSums(myMatrix)
colMeans(myMatrix)
```

Like more than two dimensions? Shine on you crazy diamond.

## Lists

Lists have data of arbitrary complexity. Any type, any length.

```{r }
x <- list()
typeof(x)
x[1] <- "Hello"
x[2] <- pi
summary(x)
str(x)
```

## 

Lists can contain other lists as elements. Note that the assignment happens a little differently.

```{r }
y <- list()
y[1] <- "Lou Reed"
y[2] <- 45

x[[3]] <- y
```

## List metadata

Again, typically names. However, these become very important for lists. Names are handled with the special `$` operator. `$` permits access to a single element. (A single element of a list can be a vector!)

```{r}
names(y) <- c("Name", "Age")
y$Name

y[[1]] <- c("Lou Reed", "Patti Smith")
y[[2]] <- c(45, 63)

y$Name
```

## Summary functions

Because lists are arbitrary, we can't expect functions like `sum` or `mean` to work. 

## Questions

* Create a list with two elements. Have the first element be a vector with 100 numbers. Have the second element be a vector with 100 dates. Give your list the names: "Claim" and "Accident Date".
* What is the average value of the first list element?

## Data frames

  * Creating
  * Referencing
  * Ordering
  * Adding new columns
  * Subsetting
  * Summarizing
  * Merging

## Creating a data frame
```{r size='tiny'}
set.seed(1234)
State = rep(c("TX", "NY", "CA"), 10)
EarnedPremium = rlnorm(length(State), meanlog = log(50000), sdlog=1)
EarnedPremium = round(EarnedPremium, -3)
Losses = EarnedPremium * runif(length(EarnedPremium), min=0.4, max = 0.9)
```
```{r eval=FALSE, size='tiny'}
plot(density(EarnedPremium))
summary(EarnedPremium)
```
```{r size='tiny'}
df = data.frame(State, EarnedPremium, Losses)
```

## Basic properties of a data frame
```{r size='tiny'}
summary(df)
str(df)
```


## More basic properties of a data frame
```{r size='tiny'}
names(df)
colnames(df)
length(df)
dim(df)
nrow(df)
ncol(df)
```


## And still more basic properties
```{r size='tiny'}
head(df)
head(df, 2)
tail(df)
```


## Enough with the basic properties already
```{r size='tiny', fig.height=4.5}
plot(df, pch=19)
```


## Referencing

Very similar to referencing a 2D matrix.

```{r eval=FALSE}
df[2,3]
df[2]
df[2,]
df[2, -1]
```


## More referencing

Note the `$` operator to access named columns

```{r eval=FALSE}
df$EarnedPremium
# Columns of a data frame may be treated as vectors
df$EarnedPremium[3]
df[2:4, 1:2]
df[, "EarnedPremium"]
df[, c("EarnedPremium", "State")]
```

## Ordering
```{r }
order(df$EarnedPremium)
df = df[order(df$EarnedPremium), ]
```

## Altering and adding columns
```{r }
df$LossRatio = df$EarnedPremium / df$Losses
df$LossRatio = 1 / df$LossRatio
```


## Eliminating columns
```{r }
df$LossRatio = NULL
df = df[, 1:2]
```

## rbind, cbind
```{r results='hide'}
dfA = df[1:10,]
dfB = df[11:20, ]
rbind(dfA, dfB)
dfC = dfA[, 1:2]
cbind(dfA, dfC)
```

## Merging
```{r size='tiny'}
dfRateChange = data.frame(State =c("TX", "CA", "NY"), RateChange = c(.05, -.1, .2))
df = merge(df, dfRateChange)
```

Merging is VLOOKUP on steroids. Basically equivalent to a JOIN in SQL.

## Altering column names
```{r }
df$LossRation = with(df, Losses / EarnedPremium)
names(df)
colnames(df)[4] = "Loss Ratio"
colnames(df)
```

## Subsetting - The easy way
```{r }
dfTX = subset(df, State == "TX")
dfBigPolicies = subset(df, EarnedPremium >= 50000)
```

## Subsetting - The hard(ish) way
```{r }
dfTX = df[df$State == "TX", ]
dfBigPolicies = df[df$EarnedPremium >= 50000, ]
```

## Subsetting - Yet another way
```{r }
whichState = df$State == "TX"
dfTX = df[whichState, ]

whichEP = df$EarnedPremium >= 50000
dfBigPolicies = df[whichEP, ]
```

## Subsetting
I use each of these three methods routinely. They're all good.

## Summarizing
```{r }
sum(df$EarnedPremium)
sum(df$EarnedPremium[df$State == "TX"])

aggregate(df[,-1], list(df$State), sum)
```

##{Summarizing visually - 1}
```{r size='tiny', fig.height=5}
dfByState = aggregate(df$EarnedPremium, list(df$State), sum)
colnames(dfByState) = c("State", "EarnedPremium")
barplot(dfByState$EarnedPremium, names.arg=dfByState$State, col="blue")
```

##{Summarizing visually - 2}
```{r size='tiny', fig.height=5}
dotchart(dfByState$EarnedPremium, dfByState$State, pch=19)
```

##{Advanced data frame tools}
  
    * plyr
    * reshape2
    * data.table
    * doBy

## Reading data

```{r eval=FALSE}
myData = read.csv("SomeFile.csv")
```

## Reading from Excel

Actually there are several ways:
* XLConnect
* xlsx
* Excelsi-r

```{r eval=FALSE}
library(XLConnect)
wbk = loadWorkbook("myWorkbook.xlsx")
df = readWorksheet(wbk, someSheet)
```

## Reading from the web - 1 

```{r eval=FALSE}
URL = "http://www.casact.org/research/reserve_data/ppauto_pos.csv"
df = read.csv(URL, stringsAsFactors = FALSE)
```

## Reading from the web - 2 

```{r eval=FALSE}
library(XML)
URL = "http://www.pro-football-reference.com/teams/nyj/2012_games.htm"
games = readHTMLTable(URL, stringsAsFactors = FALSE)
```

## Reading from a database 

```{r eval=FALSE}
library(RODBC)
myChannel = odbcConnect(dsn = "MyDSN_Name")
df = sqlQuery(myChannel, "SELECT stuff FROM myTable")
```

## Data frames 
Every time we read in data, we're creating a data frame. The data frame is a seminal concept in R. Most statistical operations expect one and they are the most common way to pass data in and out of R.

Although critical to understand, this is very, very easy to get. What's a data frame? It's a table. That's it.

Much more on data frames in the next session.

## Read some data
```{r eval=FALSE}
df = read.csv("../Data/StateData.csv")
```

```{r eval=FALSE}
View(df)
```

## Questions

* Load the data from "StateData.csv" into a data frame.
* Which state has the most premium?
