---
title: "Introduction to R"
subtitle: "Not so basics"
output:
  slidy_presentation:
    duration: 60
    fig_height: 3
    fig_width: 6
  beamer_presentation:
    fonttheme: professionalfonts
---

## Part 3

* Visualization
* Vectors
* Packages

## Visualization

It's impossible to overstate the importance of visualization in data analysis.

* Helps us explore data
* Suggest a model
* Assess the validity of a model and its parameters
* Vital for a non-technical audience

## Visualization in R

4 plotting engines (at least)

* base plotting system
* lattice
* ggplot2
* rCharts

We'll look at the base plotting system now and ggplot2 after lunch.

## Common geometric objects

* scatter
* line
* hist
* density
* boxplot
* barplot
* dotplot

plot is the most basic graphics command. There are several dozen options that you can set. Spend a lot of time reading the documentation and experimenting.

##

Open your first script.

## A basic scatter plot
```{r }
source("../scripts/BasicScript.R")
plot(X1, Y, pch=19)
```

## Add lines
The functions 'lines' and 'points' will add (wait for it) lines and points to a pre-existing plot.
```{r  eval=FALSE}
lines(X1, yHat)
```
```{r fig.height=4.5, echo=FALSE}
plot(X1, Y, pch=19)
lines(X1, yHat)
```

## 
Can everyone generate a scatter plot?

## Histogram
```{r fig.height=4.5}
hist(e)
```

## 
```{r fig.height=4.5}
set.seed(1234)
e2 = rnorm(1000, mean=0, sd=1)
hist(e2)
```

## Density plot
```{r fig.height=4.5}
plot(density(e2))
```

## Boxplot
```{r fig.height=4.5}
boxplot(e2, pch=19)
```

## Plotting a formula
```{r fig.height=4.5}
plot(Y ~ X1, pch=19)
```

## Emphasizing outliers
```{r fig.height=4.5}
colors = ifelse(abs(e) > 1.0, "red", "black")
plot(Y ~ X1, pch=19, col=colors)
```


## Other ways to emphasize outliers
```{r fig.height=4.5}
plot(Y ~ X1, pch=19)
lines(X1, yHat, lwd=2)
lines(X1, yHat+1, lty="dotted", lwd=0.5)
lines(X1, yHat-1, lty="dotted", lwd=0.5)
```

## Resources

* [Nathan Yau - FlowingData.com](http://flowingdata.com/)
* [Stephen Few - PerceptualEdge.com](http://www.perceptualedge.com/)
* [Edward Tufte - edwardtufte.com](http://www.edwardtufte.com/tufte/)
* [junkcharts.typepad.com](http://junkcharts.typepad.com/)

## Introducing vectors

In R, every variable is a vector. Think of a set of cells in a spreadsheet. Here, e is a vector with N values. X1 is the sequence of integers from 1 through 10 repeated 10 times. Vectors can grow and shrink automatically. No need to move cells around on a sheet. No need to copy formulas or change named ranges.

```{r eval=FALSE}
e  <- rnorm(N, mean = 0, sd = 1)
X1 <- rep(seq(1,10), 10)
Y  <- B0 + B1 * X1 + e
```

## Vector properties

* Vectors have one dimension
* Higher dimensions are possible via matrices and arrays
* Every element in a vector must be the same type
* Different types are possible by using a list or a data frame
* Possible to add metadata via attributes

## Vector construction

Vectors are constructed in one of several ways:

* Construction from a sequence
* Concatenation
* Return from a function or operation
* Growth by assignment

## Vector sequence

```{r results='hide'}
i <- 1:5
year = 2000:2004
pies = seq(from = 0, by = pi, length.out = 5)
```

```{r echo=FALSE}
library(rblocks)
i <- 1:5
block = make_block(i, type = 'vector')
block
```

## Concatenation

```{r results='hide'}
i <- c(1, 2, 3, 4, 5)
j <- c(6, 7, 8, 9, 10)
k <- c(i, j)
l <- c(1:5, 6:10)
```

```{r echo=FALSE}
i = c(1, 2, 3, 4, 5)
j = c(6, 7, 8, 9, 10)
k = c(i, j)
block_i = make_block(i, type = 'vector')
block_j = make_block(j, type = 'vector')
block_i[1:5] = "red"
block_j[1:5] = "blue"
block_k = make_block(c(block_i,block_j), type='vector')
block_k[1:5] = "red"
block_k[6:10] <- "blue"

block_i
block_j
block_k
```

## Return and growth

```{r results='hide'}
i = rep(pi, 100)
i = sample(1:10, 4)
i[30] = 3
```

## Vector access - by index

Vectors may be accessed by their numeric indices. Remember, ':' is shorthand to generate a sequence.

```{r results='hide'}
e[1]
e[1:4]
e[c(1,3)]
```

## Vector access - logical access

Vectors may be accessed logically.

```{r results='hide'}
i = 1:4
i[c(TRUE, FALSE, FALSE, TRUE)]
i[i > 2]
which(i > 2)
i[which(i > 2)]
b = i > 2
i[b]
```

## 

Vectors may be used in arithmetic operations. Y is now a vector with length equal to the longest vector used in the calculation.
  
```{r eval=FALSE}
Y = B0 + B1 * X1 + e
```
  
Question: B0 and B1 are vectors of length 1. X1 and e are vectors of length 100. How are they combined?


## Recycling

R will "recycle" vectors until there are enough elements to perform an operation. Everything gets as "long" as the longest vector in the operation. For scalar operations on a vector this doesn't involve any drama. Try the following code:

```{r size='tiny'}
vector1 = 1:10
vector2 = 1:5
scalar = 3

print(vector1 + scalar)
print(vector2 + scalar)
print(vector1 + vector2)
```

## What's a package?

* Allows any user to extend R's capabilities
* Must conform to a well-defined standard
* Easy to install and update
* Open source means users may test and improve the code
* Can access C or FORTRAN run-time libraries to improve performance

## Installing packages

Several ways: 

* From a CRAN mirror
* Locally
* Copy someone else's library directory
* From GitHub

The library path may be anywhere! If you have a local document repository
this is a great place to store packages without irritating your IT dept.

--- 

```{r eval=FALSE}
.libPaths()
list.files(.libPaths()[1])

install.packages("ggplot2")

remove.packages("IdontWantThisAnymore")

# Load an installed package into memory
library(MRMR)

# Will load the package and return TRUE/FALSE 
# if the package could be loaded
require(MRMR)
```

--- 

Can everyone install a package?
