<<SetParentPart3a, echo=FALSE>>=
set_parent('../Parent/RPM-Parent.Rnw')
@

\begin{frame}
  Part 3a - MRMR
\end{frame}

\begin{frame} {MRMR}
  MRMR is another R package for use in analyzing reserves.
  
  MRMR was heavily influenced by:
  \begin{itemize}
    \item Andrew Gelman and Jennifer Hill, "Data Analysis Using Regression and Multilevel/Hierarchical Models"
    \item ggplot2 and Hadley Wickham
    \item Leigh Halliwell and Judge et al
  \end{itemize}
\end{frame}

\begin{frame} {MRMR Structure}
  MRMR supports three S4 classes: Triangle, TriangleModel and TriangleProjection. These have a rough correspondence to the behavior of functions lm, glm and lme4.
  
  \begin{tabular} { | l | l | l | }
    \hline
     & R & MRMR \\ \hline
    Data storage & Data frame & Triangle \\ \hline
    Model & Function lm (S3 object) & TriangleModel \\ \hline
    Project & Function predict (vector) & TriangleProjection \\ 
    \hline
  \end{tabular}
\end{frame}

\begin{frame}[fragile]{Startup MRMR}
<<Starup-MRMR, echo=TRUE, eval=FALSE, results='hide'>>=
library(MRMR)
?MRMR
@

<<Startup2-MRMR, echo=FALSE, results='hide', message=FALSE>>=
library(MRMR)
@
\end{frame}

\begin{frame}{Basic requirements}
  A triangle object must possess the following data elements:
  \begin{itemize}
    \item Temporal dimensions for origin period, development lag and evaluation date. These are stored as lubridate objects.
    \item Measures
      \begin{itemize}
        \item Stochastic - Loss, claim, etc. These are time series variables and candidates for prediction. MRMR will adjust these so that incremental, cumulative and prior cumulative columns are formed.
        \item Static - Typically exposure variables. These will not be adjusted. These are very good candidates for predictors.
      \end{itemize}
    \item One or more grouping elements. This is almost fully implemented.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Very basic reserving data}
<<VeryBasicExample1, echo=TRUE, tidy=TRUE, results='hide', size='tiny'>>=
AccidentYear = c(2002, 2002, 2002 
               , 2003, 2003
               , 2004)

Month = c(12, 24, 36
        , 12, 24
        , 12)

Paid = c(2318,  7932, 13822
       , 1743,  6240
       , 2221)

EP = c( 61183,  61183,  61183
     ,  69175,  69175
     ,  99322)

df = data.frame(AccidentYear = AccidentYear, Month = Month, Paid = Paid, EP = EP)
@
\end{frame}

\begin{frame}[fragile] {Moving the data into a Triangle object}
<<VeryBasicExample2, echo=TRUE, tidy=TRUE, size='tiny'>>=
myTriangle = newTriangle(TriangleData = df
                         , OriginPeriods = AccidentYear
                         , DevelopmentLags = Month
                         , Cumulative = TRUE
                         , StochasticMeasures = c("Paid")
                         , StaticMeasures = c("EP")
                         , Verbose = FALSE)
@
\end{frame}

\begin{frame}[fragile]{What's in a Triangle object?}
One may identify the components of a list object by using the name function. For an S4 object, use the function slotNames.
<<VeryBasicExample3, echo=TRUE>>=
slotNames(myTriangle)
@
To access a slot, use the $@$ operator
\end{frame}

\begin{frame}[fragile]{What sort of data frame have I created?}
<<VeryBasicExample3-1, echo=TRUE, tidy=TRUE>>=
names(myTriangle@TriangleData)
@
\end{frame}

\begin{frame}[fragile]{A very basic plot}
<<VeryBasicExample4, fig.width=8, fig.height=5, echo=TRUE, tidy=FALSE, size='tiny'>>= 
plotTriangle(myTriangle, Predictor = "DevInteger", Response = "CumulativePaid")
@
\end{frame}

\begin{frame}[fragile]{Something more complex}
<<Friedland1, fig.width=8, fig.height=5, echo=TRUE, tidy=FALSE, size='tiny'>>=
data(Friedland)
plotTriangle(Friedland, Predictor = "DevInteger", Response = "CumulativePaid")
@
\end{frame}

\begin{frame}[fragile]{Change the response term}
<<Friedland2, fig.width=8, fig.height=5, echo=TRUE, size='tiny'>>=
plotTriangle(Friedland, Predictor = "DevInteger", Response = "IncrementalPaid")
@
\end{frame}

\begin{frame}[fragile]{Change the time axis}
<<Friedland3, fig.width=8, fig.height=5, echo=TRUE, size='tiny'>>=
plotTriangle(Friedland, Predictor = "EvaluationDate", Response = "IncrementalPaid")
@
\end{frame}

\begin{frame}[fragile]{Change the grouping dimension}
<<FriedlandCL1, fig.width=8, fig.height=5, echo=TRUE, size='tiny'>>=
plotTriangle(Friedland, Predictor = "PriorPaid", Response ="IncrementalPaid", Group = "DevInteger", Lines = FALSE)
@
\end{frame}

\begin{frame}[fragile]{Add fit lines}
<<Friedland5, fig.width=8, fig.height=5, echo=TRUE, size='tiny'>>=
plotTriangle(Friedland, Predictor = "PriorPaid", Response ="IncrementalPaid", Group = "DevInteger", Lines = FALSE, FitLines = TRUE)
@
\end{frame}

\begin{frame}[fragile]{Change the predictor variable}
<<Friedland4, fig.width=8, fig.height=5, echo=TRUE, size='tiny'>>=
plotTriangle(Friedland, Response ="IncrementalPaid", Predictor = "EP", Group = "DevInteger", Lines = FALSE, FitLines=TRUE)
@
\end{frame}

\begin{frame}[fragile]{Fit a model}
<<FitPaidAM, echo=TRUE, size='tiny'>>=
PaidAM = newTriangleModel(Triangle = Friedland, Response = "IncrementalPaid", Predictor = "EP", FitCategory = "DevInteger", Tail = 6)
@
\end{frame}

\begin{frame}[fragile]{Visualization is closely related to a model}
<<echo=TRUE, eval=FALSE, results='hide', size='tiny'>>=
plotTriangle(Friedland, Response ="IncrementalPaid", Predictor = "EP", Group = "DevInteger", Lines = FALSE, FitLines=TRUE)
PaidAM = newTriangleModel(Friedland, Response ="IncrementalPaid", Predictor = "EP", FitCategory = "DevInteger", Tail = 6)
@
\end{frame}

\begin{frame}[fragile]{Two different reserving models}
<<GetTwoModels, echo=TRUE, size='tiny'>>=
PaidCL = newTriangleModel(Friedland, Response ="IncrementalPaid", Predictor = "PriorPaid", FitCategory = "DevInteger", Tail = 6)
PaidAM = newTriangleModel(Triangle = Friedland, Response = "IncrementalPaid", Predictor = "EP", FitCategory = "DevInteger", Tail = 6)
@
The first model corresponds to the traditional multiplicative chain ladder as applied to paid losses. The default is to have no weighting.
\newline The second model is the additive model. This is described in Stanard and elsewhere.
\end{frame}

\begin{frame}[fragile]
<<CLDiagnostics, echo=TRUE, size='tiny', tidy.opts=list(width=80), tidy=TRUE>>=
summary(PaidCL@Fit)$coefficients[,1:2]
@
\end{frame}

\begin{frame}[fragile]{Observe the model factors - Chain Ladder}
<<PlotModelFactorsCL, fig.width=8, fig.height=5, echo=TRUE>>=
PlotModelFactors(PaidCL)
@
\end{frame}

\begin{frame}[fragile]{Observe the model factors - Additive}
<<PlotModelFactorsAM, fig.width=8, fig.height=5, echo=TRUE>>=
PlotModelFactors(PaidAM)
@
\end{frame}

\begin{frame}[fragile]{Linear regression assumptions}
  \begin{enumerate}
    \item Linear model with specified parameters
      \begin{itemize}
        \item Significance of individual model factors
        \item Significance of model
      \end{itemize}
    \item Functional form of errors
    \item Independence of errors
      \begin{itemize}
        \item (Serial) correlation of errors
        \item Homoskedasticity
      \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Significance of model}
  Several metrics
  \begin{enumerate}
    \item R-squared
    \item F-statistic
    \item AIC
    \item Penalized measures
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{Diagnostics}
<<UnivariateDiagnostics2, echo=TRUE>>=
myFit = PaidAM@Fit
summary(myFit)$r.squared
summary(myFit)$fstatistic
@
Be careful of both of these statistics. Always visualize your data!
\end{frame}

\begin{frame}[fragile]{Always observe the residual plots!}
<<ResidualPlotsAM, fig.width=8, fig.height=5, echo=TRUE>>=
PlotResiduals(PaidAM)
@
\end{frame}

\begin{frame}[fragile]{Test for normalcy}
<<ShapiroWilkOutput, echo=TRUE>>=
shapiro.test(e)
@
<<ShapiroWilkPlot, echo=TRUE, eval=FALSE>>=
qqnorm(e)
qqline(e)
@
\end{frame}

\begin{frame}[fragile]
<<ShapiroWilkPlot2, echo=FALSE, fig.width=8, fig.height=5>>=
qqnorm(e, pch=19)
qqline(e)
@
\end{frame}

% \begin{frame}[fragile]{Error correlation}
% <<SerialCorrelationPlot, echo=TRUE, fig.width=8, fig.height=5>>=
% lstFitResults = plotSerialCorrelation(PaidAM)
% @
% \end{frame}
% 
% \begin{frame}[fragile]{Error summary}
% <<SerialCorrelationSummary, echo=TRUE, size='tiny'>>=
% summary(lstFitResults$fit)$coefficients
% @
% \end{frame}
% 
% \begin{frame}[fragile]{Introduce correlation}
% <<>>=
% df = Friedland@TriangleData
% cy = (year(df$EvaluationDate) == 2008)
% df$IncrementalPaid[cy] = df$IncrementalPaid[cy] * (2/3)
% 
% myTriangle = newTriangle(df, OriginPeriods = OriginPeriod, DevelopmentLags = DevelopmentLag
%                          , StaticMeasures = "EP"
%                          , StochasticMeasures = "IncrementalPaid"
%                          , Cumulative = FALSE)
% 
% myModel = newTriangleModel(myTriangle, "IncrementalPaid", "EP", "DevInteger")
% @
% \end{frame}

% \begin{frame}[fragile]{Error summary}
% <<SerialCorrelationSummary2, echo=TRUE, size='tiny'>>=
% lstResult = FitSerialCorrelation(myModel)
% summary(lstResult$fit)$coefficients
% @
% \end{frame}

\begin{frame}[fragile]{Breusch-Pagan}
Heteroskedasticity is most often detected by observing the residuals. Adjusting the weights of the regression is an implicit assumption about the variance of the response variable. Changing the alpha parameter allows one to adjust for presumed heteroskedasticity. Read papers by Dan Murphy (or just ask him, he's probably standing somewhere close by) to learn more.
\newline There is a formal test from Breusch and Pagan, which is available from the lmtest package.
\end{frame}

\begin{frame}[fragile]
<<BreuschPagan1, echo=TRUE, size='tiny'>>=
set.seed(1234)
N = 100
e = rnorm(N, mean = 0, sd = 1)
B1 = 1.5
X1 = rep(seq(1,10),10)
Y = B1 * X1 + sqrt(X1) * e

bpFit = lm(Y ~ 0 + X1)
bptest(bpFit)
coef(bpFit)
@
<<echo=TRUE, eval=FALSE>>=
plot(X1, residuals(bpFit), pch=19)
@
\end{frame}

\begin{frame}[fragile]
<<BrueschPaganPlot, echo=FALSE>>=
plot(X1, residuals(bpFit), pch=19)
@
\end{frame}

% \begin{frame}[fragile]
% <<AlphaPlot, echo=TRUE>>=
% alpha = seq(-10, 10,by=.05)
% slope = sapply(alpha, function(x){
%   w = X1 ^ x
%   fit = lm(Y ~ 0 + X1, weight = w)
%   coef(fit)
% })
% max(Y / X1)
% min(Y / X1)
% max(slope)
% min(slope)
% @
% <<echo=TRUE, eval=FALSE>>=
% plot(alpha, slope, pch = 19)
% @
% \end{frame}

\begin{frame}[fragile]{Heteroskedasticity is controlled through the alpha parameter}
<<MRMRAlpha, echo=TRUE, eval=FALSE, size='tiny'>>=
PaidAM0 = newTriangleModel(Friedland, Response = "IncrementalPaid", Predictor = "EP", FitCategory="DevInteger", Tail=6, Alpha=1)
PaidAM0 = newTriangleModel(Friedland, Response = "IncrementalPaid", Predictor = "EP", FitCategory="DevInteger", Tail=6, Alpha=2)
@
\end{frame}

\begin{frame}[fragile]{Projection to as-of date}
Once a model has been checked and selected, projection of losses is trivial. MRMR will either project to a specific date or a specific development lag.
<<size='tiny'>>=
PaidAM_Projection = TriangleProjection(PaidAM, ProjectToDev = FALSE, AsOfDate = mdy("12/31/2010"))
df = PaidAM_Projection@ProjectionData
@
\end{frame}

\begin{frame}[fragile]{Projection to development age}
<<size='tiny'>>=
PaidAM_Projection = TriangleProjection(PaidAM, ProjectToDev = TRUE, MaxDev = 10)
df = PaidAM_Projection@ProjectionData
@
\end{frame}